<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Ultimate Colour Picker</title>
		<link rel="stylesheet" type="text/css" href="style.css">
		<style>

		</style>
	</head>
	<body>
		<div id="info">
			<ul>
				<li>Right click and drag: rotate camera</li>
				<li>Mouse wheel: zoom</li>
				<li>Left click and drag: move nodes</li>
				<li>Q: toggle Perspective/Orthographic view</li>
				<li>Y (hold): lock chromaticity</li>
				<li>N: add new node</li>
			</ul>				
		</div>
		<div id="panel">
			<div id="panelcolours">
				<template id="nodeinspectortemplate">
					<div class="nodeinspector">
						<div class="inspectorcoloursquare"></div>
						<div class="inspectorcolourright">
							<div class="inspectorcolourname"></div>
							<div class="inspectorcolourinfo"></div>

						</div>
						<div class="inspectornodedelete"><a>x</a></div>

					</div>
				</template>
			</div>
			<div id="panelramps">
				<template id="rampinspectortemplate">
					<div class="rampinspector">
						<div class="inspectorramprect">
						</div>
						<div class="slidercontainer">
  							<input type="range" min="-0.5" max="1" value="0" step="0.005" class="lambdaslider">
						</div>
						<div class="slidercontainer">
  							<input type="range" min="-1" max="1" value="0" step="0.005" class="muslider">
						</div>
					</div>
				</template>
			</div>
		</div>
		<script src="scripts/three.min.js"></script>
		<script src="scripts/DragControls.js"></script>
		<script src="scripts/OrbitControls.js"></script>
			<script src="scripts/LineMaterial.js"></script>
			<script src="scripts/LineSegments2.js"></script>
			<script src="scripts/LineSegmentsGeometry.js"></script>
			<script src="scripts/LineGeometry.js"></script>
			<script src="scripts/Line2.js"></script>
			
		  <script src="https://unpkg.com/three-spritetext"></script>
		  <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.0.6/chroma.min.js"></script>
		  <script src="https://cdn.jsdelivr.net/npm/everpolate@0.0.3/everpolate.browserified.min.js"></script>
		  <script src="scripts/ntc.js"></script>
		<script>

			var nodeInspectorTemplate = document.querySelector("#nodeinspectortemplate");
			var rampInspectorTemplate = document.querySelector("#rampinspectortemplate");


			const frustumSize = 2;

			const toneCodes = ["RO","O","OY","Y","YG","G","BG","B","BV","V","VR","R"];

			const fletch_h = [19, 37, 45, 63, 83, 102, 122, 137, 170, 263, 302, 331, 19 + 360, 
 37 + 360, 45 + 360, 63 + 360];
 			const Fvals = [-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13];

 			var linearinterp = everpolate.linear;

 			function Ftoh(F){
 				return linearinterp(F,Fvals,fletch_h);
 			}



			var lockChromaticity = false;


			var scene = new THREE.Scene();

			scene.background = new THREE.Color(.5,.5,.5);


			var camera;
            var cameraPerspective = true;

            var dragControls;

            function setupCamera(){
            	var campos = new THREE.Vector3();
            	if(typeof camera != "undefined"){
            	campos = camera.position.clone();
            	};

            	if(cameraPerspective){
            		camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 100 );
					camera.up = new THREE.Vector3(0,0,1);



            	}
            	else{
            		
            		var aspect = window.innerWidth/window.innerHeight;
            		camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2,  frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 0.001, 100 );
            		camera.up = new THREE.Vector3(0,0,1);

            	}

            	camera.position.copy(campos);
				camera.lookAt(new THREE.Vector3());
            	camera.updateProjectionMatrix();
            		
            }

            setupCamera();

            function switchCameraMode(){
            	cameraPerspective = !cameraPerspective;
            	setupCamera();
            	updateCamera();
            	orbitControls.object = camera;
            	orbitControls.update();
            	CreateDragControls();
            }
			
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

            function updateCamera(){
            	renderer.setSize( window.innerWidth, window.innerHeight );
            	var aspect = window.innerWidth / window.innerHeight;
            	if(cameraPerspective){
            		camera.aspect = aspect;
					camera.up = new THREE.Vector3(0,0,1);
					camera.lookAt(new THREE.Vector3());

            	}
            	else
            	{

            		camera.left = frustumSize * aspect / - 2;
            		camera.right = frustumSize  *aspect/ 2;
            		camera.top = frustumSize  / 2;
            		camera.bottom = - frustumSize / 2;
            		camera.aspect = aspect;
            	
            		
            	}
            	camera.updateProjectionMatrix();
            	if(typeof orbitControls != "undefined")
            		orbitControls.update();
            	if(typeof dragControls != "undefined")
            		dragControls.camera = camera;
            	
            }



            window.addEventListener('resize', onWindowResize, false);
            function onWindowResize(){

            	updateCamera();
            }

			

			var whitePointGrid = new THREE.Object3D();
			whitePointGrid.position.set(0,0,0);

			var gridMaterial = new THREE.LineBasicMaterial( {color: 0xffffffff});


			var geometryAxes = new THREE.Geometry();

			var k;
			for (k=0; k<12; k++)
			{
				var theta = -2* Math.PI * k / 12.0;
				geometryAxes.vertices.push(new THREE.Vector3(-Math.cos(theta),-Math.sin(theta),0));
				geometryAxes.vertices.push(new THREE.Vector3(Math.cos(theta),Math.sin(theta),0));

				var clabel = new SpriteText(toneCodes[k],0.03);
				clabel.color ='white';
				clabel.position.set(Math.cos(theta),Math.sin(theta),0);
				clabel.position.multiplyScalar(1.1);
				clabel.material.sizeAttenuation=false;
				whitePointGrid.add(clabel);
			}

			var nlabel = new SpriteText("N",0.03);
			nlabel.color = "white";
			nlabel.position.set(0,0,0);
			nlabel.material.sizeAttenuation = false;
			scene.add(nlabel);

			var Axes = new THREE.LineSegments(geometryAxes, gridMaterial);

			whitePointGrid.add(Axes);

			scene.add(whitePointGrid);


			function xytoFC(x,y){
				var angle = (-Math.atan2(y,x)+2*Math.PI)%(2*Math.PI);
				var out = {};
				out.F = angle /(2*Math.PI) * 12;

				out.C = Math.sqrt(y*y +  x*x);
				
				return out;
			}

			function FCLtoRGB(F,C,L) {
				h = Ftoh(F);
				return chroma.lch(L,C,h)
			}

			function postoxyL(pos){
				var out = {};
				out.x = 100*pos.x;
				out.y = 100*pos.y;
				out.L = 50*(pos.z+1);
				return out;

			}

			function xyLtopos(x,y,L){
				return new THREE.Vector3(x/100.0,y/100.0,L/50.-1.);
			}

			class Node{
				constructor(L,x,y){
					this.L = L;
					this.x = x;
					this.y = y;

					this.onColourUpdatedListeners = [];
				};

				onColourUpdated(){
					this.onColourUpdatedListeners.forEach( lisner => lisner.onColourUpdated() );
				};


				update(){

					//this.position = new THREE.Vector3(this.x/100.,this.y/100.,this.L/50.-1);
					this.position = xyLtopos(this.x,this.y,this.L);

					var FC = xytoFC(this.x,this.y)
					this.F = FC.F;
					this.C = FC.C;
					

					this.rgb = FCLtoRGB(this.F,this.C,this.L);		


					if(this.rgb.clipped()){
						if(lockChromaticity){
							if(this.Lincreased){
								this.L = this.L - 0.005;
							}
							else
							{
								this.L = this.L + 0.005;
							}

							this.update();
							return;

						}
					}

					if(this.L<0 || this.L>100){

						this.L = Math.max(0,Math.min(99.999,this.L));
						this.x = 0;
						this.y = 0;
						this.update();
						return;
					}

					if(this.rgb.clipped()){

						//gamut wall binary search
						var step = this.C;
						var tC = this.C;
						var clipped = true;

						for(var i=0; i<10; i++){
							step = step/2;
							tC = tC + (clipped ? -step : step);

							clipped = FCLtoRGB(this.F,tC,this.L).clipped();
							
						}

						if(clipped)
							tC = tC-step;

						this.x *= tC / this.C;
						this.y *= tC / this.C;


						this.update();
						return;

					}


				}

				stringFCL(){
					var befcol = toneCodes[Math.floor(this.F)];
					var aftcol = toneCodes[Math.floor(this.F+1)%12];
					var frac = this.F%1;
					var cname;
					if(frac < 0.25)
						cname = befcol;
					else if (frac < 0.75)
						cname = `${befcol}-${aftcol}`;
					else
						cname = aftcol;

					if (this.C < 0.3)
						cname = "N";
					

					
					return `L=${this.L.toFixed(1)}, C=${this.C.toFixed(1)}, F=${this.F.toFixed(2)} (${cname})`
				}

				kill(){
					this.onColourUpdatedListeners.forEach(lisner => lisner.kill());
				}


				
			}


			var draggableNodes = [];

			class DraggableNode extends Node{
				constructor(L,x,y){
					super(L,x,y);
					this.size = 0.07;

					this.boxGeometry = new THREE.BoxGeometry(this.size,this.size,this.size);
					this.boxMaterial = new THREE.MeshBasicMaterial( 
						{ color: 0xffffff});
					this.box = new THREE.Mesh(this.boxGeometry,this.boxMaterial);

					this.box.daddy = this;

					scene.add(this.box);
					draggableNodes.push(this.box);


					this.inspectorDiv = nodeInspectorTemplate.content.cloneNode(true);

					this.topDiv = this.inspectorDiv.querySelector(".nodeinspector");
					this.squareDiv = this.inspectorDiv.querySelector(".inspectorcoloursquare");
					this.nameDiv = this.inspectorDiv.querySelector(".inspectorcolourname");
					this.infoDiv = this.inspectorDiv.querySelector(".inspectorcolourinfo");
					this.deleteA = this.inspectorDiv.querySelector("a");
					var thisnode = this;
					
					
					this.Lincreased = false;
					this.update();

					
					this.inspectorDiv = document.getElementById("panelcolours").appendChild(this.inspectorDiv);

					this.deleteA.addEventListener("click",this.onClickDelete.bind(this));

				}

				onClickDelete(){
					
					this.kill();
				}

				kill(){
					super.kill();
					scene.remove(this.box);
					draggableNodes.splice(nodes.indexOf(this.box),1);
					this.topDiv.remove();
				}

				update(){
					super.update();

					this.box.material.color.set(this.rgb.hex());
					this.box.position.copy(this.position);

					this.box.updateMatrixWorld();

					this.onColourUpdated();

				}
				onColourUpdated(){
					super.onColourUpdated();
					if(typeof this.inspectorDiv != "undefined"){
						var hex = this.rgb.hex();
						this.squareDiv.style.background = hex;

						this.nameDiv.innerHTML = ntc.name(hex)[1];
						this.infoDiv.innerHTML = this.stringFCL();
					}
				}

				updateFromPosition(){
					var oldL = this.L

					var position = this.box.position;

					var xyL = postoxyL(position);

					if (!lockChromaticity){
						this.x = xyL.x;
						this.y = xyL.y;
					};
					this.L = xyL.L;

					this.Lincreased = this.L > oldL;
					
					this.update();
				}
			}

			class WhitePointNode extends DraggableNode{
				constructor(L,x,y){
					super(L,x,y);
					var osize = this.size * 1.1;
					var outlineMaterial = new THREE.MeshBasicMaterial( 
						{ color: 0x000000, side: THREE.BackSide});
					var outlineGeometry = new THREE.BoxGeometry(osize,osize,osize);
					this.outline = new THREE.Mesh(outlineGeometry,outlineMaterial);
					scene.add(this.outline);

					this.deleteA.remove();
				}

				onColourUpdated() {
					super.onColourUpdated();
					scene.background = this.box.material.color.clone();
					whitePointGrid.position.set(this.box.position.x,this.box.position.y,0);
					if(typeof this.outline != "undefined"){
						this.outline.position.copy(this.box.position);

					}
				}
			}


			var	rampMaterial = new THREE.LineMaterial( { 
				color: 0xffffff, 
				vertexColors: THREE.VertexColors,
				linewidth:0.01
			} );

			class Ramp{
				constructor(n1,n2){
					this.n1 = n1;
					this.n2 = n2;



					this.geometry = new THREE.LineGeometry();
					this.N = 12;
					var positions = new Float32Array(this.N * 3);
					this.geometry.setPositions(positions);
					var colours = new Float32Array(this.N * 3);
					this.geometry.setColors(colours);

					this.line = new THREE.Line2(this.geometry,rampMaterial);
					this.line.computeLineDistances();
					scene.add(this.line);

					this.lambda = 0;
					this.mu = 0;

					this.inspectorDiv = rampInspectorTemplate.content.cloneNode(true);

					this.lambdaSlider = this.inspectorDiv.querySelector(".lambdaslider");
					this.muSlider = this.inspectorDiv.querySelector(".muslider");
					this.rectDiv = this.inspectorDiv.querySelector(".inspectorramprect");
					this.inspectorDiv = document.getElementById("panelramps").appendChild(this.inspectorDiv);


					this.n1.onColourUpdatedListeners.push(this);
					this.n2.onColourUpdatedListeners.push(this);

					this.lambdaSlider.addEventListener("input",this.update.bind(this));
					this.muSlider.addEventListener("input",this.update.bind(this));
					//this.lambdaSlider.addEventListener("onchange",this.update.bind(this));


					this.update();
				}

				getxyL(t,tL){
					var out = {};
					out.L = this.n2.L * tL +  this.n1.L * (1-tL);
					out.x = this.n2.x * t +  this.n1.x * (1-t);
					out.y = this.n2.y * t +  this.n1.y * (1-t);
					return out;
				}



				update() {
					this.lambda = this.lambdaSlider.value;
					this.mu = this.muSlider.value;
					var maxblowup = Math.exp(-this.lambda);

					var midxyL = this.getxyL(0.5,0.5);

					var positions = [];
					var colours = [];
					var hexes = [];
					for(var k=0;k<this.N;k++){
						var t = 1.0 / (this.N-1) * k;

						var t2 = 4*(t-t*t);
						var blowup = (1-t2)+t2*maxblowup;

						var tL = t - this.mu * (t*t-t);

						var xyLraw = this.getxyL(t,tL);

						var x = xyLraw.x - this.lambda * midxyL.x * t2;
						var y = xyLraw.y - this.lambda * midxyL.y * t2;
						var L = xyLraw.L;

						var pos = xyLtopos(x,y,L);

						var FC = xytoFC(x,y);
						var col = FCLtoRGB(FC.F,FC.C,L);
						var gl = col.gl();

						if(col.clipped())
							gl = [0,0,0];
						

						positions.push(pos.x,pos.y,pos.z);
						colours.push(gl[0],gl[1],gl[2]);
						hexes.push(col.hex());

					}
					
					this.line.geometry.setPositions(positions);
					this.line.geometry.setColors(colours);
					this.rectDiv.style.backgroundImage = "linear-gradient(to right,"+ hexes.join(',') + ")";
				}

				onColourUpdated(){

					this.update();
					
				}

				kill(){
					scene.remove(this.line);
				}
			}





			var gnode = new WhitePointNode(50,0,0);



			function randomNode(){
				 return new DraggableNode(Math.random()*100,Math.random()*200-100,Math.random()*200-100);
			}

			//for(var i =0;i<40; i++){
			// 	var newnode = new Node(Math.random()*100,Math.random()*200-100,Math.random()*200-100);
			// 	nodes.push(newnode.box);
			// }

			var test1 = randomNode();
			var test2 = randomNode();
			var ramp = new Ramp(test1,test2);

			function addNewNode(){
				var newnode = randomNode();

			}




				var orbitControls = new THREE.OrbitControls(camera,renderer.domElement);
				orbitControls.enablePan = false;
				orbitControls.enableZoom = true;
				orbitControls.enableDamping = true;
				orbitControls.mouseButtons = {
					RIGHT: THREE.MOUSE.ROTATE,
					LEFT: THREE.MOUSE.PAN,
					MIDDLE: THREE.MOUSE.DOLLY
				}
				camera.position.set(2,0,0);
				camera.lookAt(new THREE.Vector3);
				orbitControls.update();

			function CreateDragControls() {
				if(typeof dragControls != "undefined"){
					dragControls.dispose();
				}
				dragControls = new THREE.DragControls( draggableNodes, camera, renderer.domElement);

				dragControls.addEventListener( 'drag', function ( event ) {
				 		event.object.daddy.updateFromPosition();
				 	} );

				dragControls.addEventListener( 'dragstart', function ( event ) {
				 		orbitControls.enabled = false;
				 	} );
				dragControls.addEventListener( 'dragend', function ( event ) {
						event.object.daddy.updateFromPosition();
				 		orbitControls.enabled = true;
				 	} );
			};

			CreateDragControls();


			document.addEventListener("keydown", onDocumentKeyDown, false);
			document.addEventListener("keyup", onDocumentKeyUp, false);
            function onDocumentKeyDown(event) { 
                 if (event.key == "q") {
                     switchCameraMode();     
                 };
                 if (event.key == "y") {
                 	lockChromaticity = true;
                 };
                 if (event.key == "n") {
                 	addNewNode();
                 };
            };
            function onDocumentKeyUp(event) { 
                 if (event.key == "y") {
                 	lockChromaticity = false;
                 };
            };




			// var updateCamera = function() {
			// 	camera.position.set(Math.cos(azimuth)*Math.cos(altitude),Math.sin(azimuth)*Math.cos(altitude),Math.sin(altitude));
			// 	camera.position.multiplyScalar(2);
			// 	camera.lookAt(new THREE.Vector3());
			// 	camera.updateMatrix();
			// }

			var animate = function () {
				requestAnimationFrame( animate );

				// cube.rotation.x += 0.01;
				// cube.rotation.y += 0.01;

				orbitControls.update();

				renderer.render( scene, camera );

			};

			animate();
		</script>
	</body>
</html>